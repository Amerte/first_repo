import asyncio
import aiohttp
import numpy as np
import talib
import time
from aiogram import Bot, Dispatcher
from aiogram.types import Message
from aiogram.utils import executor

# === –ù–ê–°–¢–†–û–ô–ö–ò ===
API_KEY = "7707174304:AAH5i6cmFMEQaxD80R9OM0QbC_6J-PhdDmE"
CHAT_ID = "234878090"  # —Å—é–¥–∞ –±—É–¥—É—Ç –ø—Ä–∏—Ö–æ–¥–∏—Ç—å —Å–∏–≥–Ω–∞–ª—ã
BOT = Bot(token=API_KEY)
DP = Dispatcher(BOT)

GATE_API = "https://api.gateio.ws/api/v4"

# === –§–£–ù–ö–¶–ò–ò ===

async def fetch_json(session, url):
    async with session.get(url) as resp:
        return await resp.json()

async def get_top_300_pairs(session):
    """–ü–æ–ª—É—á–∞–µ–º —Ç–æ–ø-300 –ø–∞—Ä –ø–æ –æ–±—ä–µ–º—É (USDT)"""
    url = f"{GATE_API}/spot/tickers"
    data = await fetch_json(session, url)
    usdt_pairs = [x for x in data if x["currency_pair"].endswith("_USDT")]
    sorted_pairs = sorted(usdt_pairs, key=lambda x: float(x["quote_volume"]), reverse=True)
    return [p["currency_pair"] for p in sorted_pairs[:300]]

async def get_candles(session, pair, interval="15m", limit=200):
    """–ü–æ–ª—É—á–∞–µ–º —Å–≤–µ—á–∏"""
    url = f"{GATE_API}/spot/candlesticks?currency_pair={pair}&interval={interval}&limit={limit}"
    data = await fetch_json(session, url)
    # –û—Ç–≤–µ—Ç Gate –∏–¥–µ—Ç –æ—Ç —Å—Ç–∞—Ä–æ–π –∫ –Ω–æ–≤–æ–π, —Ä–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞–µ–º
    candles = list(reversed(data))
    closes = np.array([float(c[2]) for c in candles], dtype=np.float64)
    highs = np.array([float(c[3]) for c in candles], dtype=np.float64)
    lows = np.array([float(c[4]) for c in candles], dtype=np.float64)
    return closes, highs, lows

def calc_rsi(closes, period=14):
    return talib.RSI(closes, timeperiod=period)

def nearest_levels(highs, lows, left=5, right=5):
    """–ü—Ä–æ—Å—Ç–µ–π—à–∏–π —Ä–∞—Å—á–µ—Ç —É—Ä–æ–≤–Ω–µ–π –ø–æ–¥–¥–µ—Ä–∂–∫–∏/—Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—è —á–µ—Ä–µ–∑ –ª–æ–∫–∞–ª—å–Ω—ã–µ —ç–∫—Å—Ç—Ä–µ–º—É–º—ã"""
    supports, resistances = [], []
    for i in range(left, len(highs) - right):
        if lows[i] == min(lows[i - left:i + right]):
            supports.append(lows[i])
        if highs[i] == max(highs[i - left:i + right]):
            resistances.append(highs[i])
    return supports, resistances

def check_signal(closes, highs, lows):
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ —É—Å–ª–æ–≤–∏–π —Å–∏–≥–Ω–∞–ª–∞"""
    rsi = calc_rsi(closes)
    last_rsi = rsi[-1]
    price = closes[-1]

    # –£—Ä–æ–≤–Ω–∏
    supports, resistances = nearest_levels(highs, lows)
    nearest_sup = max([s for s in supports if s <= price], default=None)
    nearest_res = min([r for r in resistances if r >= price], default=None)

    signal = None

    if last_rsi < 30 and nearest_sup and abs(price - nearest_sup) / price < 0.01:
        signal = f"üü¢ LONG —Å–∏–≥–Ω–∞–ª: RSI={last_rsi:.1f}, —Ü–µ–Ω–∞ —É –ø–æ–¥–¥–µ—Ä–∂–∫–∏ {nearest_sup:.4f}"
    elif last_rsi > 70 and nearest_res and abs(price - nearest_res) / price < 0.01:
        signal = f"üî¥ SHORT —Å–∏–≥–Ω–∞–ª: RSI={last_rsi:.1f}, —Ü–µ–Ω–∞ —É —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—è {nearest_res:.4f}"

    return signal

async def scan_market():
    async with aiohttp.ClientSession() as session:
        pairs = await get_top_300_pairs(session)
        results = []
        for pair in pairs:
            try:
                closes, highs, lows = await get_candles(session, pair)
                signal = check_signal(closes, highs, lows)
                if signal:
                    results.append((pair, signal))
            except Exception as e:
                print(f"–û—à–∏–±–∫–∞ {pair}: {e}")
        return results

async def job():
    while True:
        print("üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä—ã–Ω–∫–∞...")
        signals = await scan_market()
        if signals:
            for pair, sig in signals:
                text = f"üìä {pair}\n{sig}"
                await BOT.send_message(CHAT_ID, text)
        else:
            print("–°–∏–≥–Ω–∞–ª–æ–≤ –Ω–µ—Ç.")
        await asyncio.sleep(15 * 60)  # –∫–∞–∂–¥—ã–µ 15 –º–∏–Ω—É—Ç

# === –°–¢–ê–†–¢ ===
if __name__ == "__main__":
    loop = asyncio.get_event_loop()
    loop.create_task(job())
    executor.start_polling(DP, skip_updates=True)
